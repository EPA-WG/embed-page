<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">

    <title>embed-page demo</title>

    <script src="../node_modules/@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>

    <script type="module">
      import '@polymer/iron-demo-helpers/demo-pages-shared-styles';
      import '@polymer/iron-demo-helpers/demo-snippet';
    </script>

    <script src="../embed-page.js"  type="module" ></script>
    <script src="code-view.js"></script>

    <custom-style>
      <style is="custom-style" include="demo-pages-shared-styles"></style>
    </custom-style>
    <style>
        @import "page.css";
        iframe{width: 100%;}
        fieldset{display: inline-block; border-bottom: none; border-right: none;}
        embed-page{ box-shadow: inset 0 0 2em #000000; padding: 1em; }
        dl{ border-left: 1em solid lightgray; padding-left: 1em; }
        @media (max-width: 500px) { body,fieldset{padding: 0; border-left: none} }
        @media (min-width: 100em) { fieldset{width:46%} }
        #purple-color{ color: purple;}
        #violet-color{ color: violet;}
    </style>
  </head>
  <body>


    <embed-page src="demo-menu.html" scope="none" ></embed-page>
    <h1>Basic &lt;embed-page&gt; demo</h1>
    <i> <a href="https://github.com/EPA-WG/EPA-concept" >EPA-WG</a> (Embeddable Progressive Applications Working Group)</i>
    <p> The <code>&lt;embed-page/&gt;</code> is a proof of concept for Embeddable Progressive Application
        - a microapplication container implemented as WebComponent acting as</p>
    <dl>
        <dt> Seamless IFRAME.</dt>
        <dd>        Its content is embedded into page DOM, but insulated on JS, DOM, CSS and browsing context level( A links and FORM get/post ).<br/>
                    Unlike IFRAME it is embedded inline into parent page DOM and automatically resizing parent node.
        </dd>
        <dt> HTML include.</dt>
        <dd>        With plain html and JS/css injection into page content.
        </dd>
    </dl>
    <h2>Where to use?</h2>
    <code>&lt;embed-page/&gt;</code>  covers 2 extreme cases.
    <ol>
        <li>Super-<b>simple</b> development with library of pre-made microapplications and plain html codebase.
            It assumes no web component knowledge and development.</li>
        <li>Super-<b>complex</b> apps where on same page need to mix UX made with different frameworks and their incompatible otherwise revisions.<br/>
            The JS Context insulation of embed-page provides "evolutionary architecture" support to web page.</li>
    </ol>
    <h2>Demo cases</h2>
    <label>Change <var>src</var> attribute to
        <select onchange="document.getElementsByTagName('embed-page')[1].src=this.value">
            <option value="page-violet.html" selected="selected"           >page-violet.html            </option>
            <option value="page-purple.html"                               >page-purple.html            </option>
        </select>
    </label>
      <demo-snippet>
        <template>
            <embed-page src="page-violet.html" id="epa-0"></embed-page>
        </template>
      </demo-snippet>

    <fieldset>
        <legend><a href="page-purple.html" target="_blank">page-purple.html</a> </legend>
        <legend>as <code>&lt;embed-page&gt;</code></legend>
        <embed-page src="page-purple.html?a=b#c" id="epa-purple"></embed-page>
        <legend> in IFRAME</legend>
        <iframe src="page-purple.html"></iframe>
        <legend> Source </legend>

        <code src="./page-purple.html"></code>
    </fieldset>

    <fieldset>
        <legend><a href="page-violet.html" target="_blank">page-violet.html</a> </legend>
        <legend>as <code>&lt;embed-page&gt;</code></legend>
        <embed-page src="page-violet.html?d=e#f"  id="epa-violet"></embed-page>
        <p>&nbsp;</p>
        <legend> in IFRAME</legend>
        <iframe src="page-violet.html"></iframe>
        <legend> Source </legend>

        <code src="./page-violet.html"></code>
    </fieldset>
    <br/>
    <fieldset>
        <legend>Demo(this) page </legend>
        <div style="display: inline-block">
            <h1>Default style header</h1>
            The content of this section, page-violet.html, and page-purple.html is identical.<br/>
            Scripts and CSS rules are operating with same IDs and class names.
            <ul><li>    <input   id="embedded" class="embedded" type="checkbox" >
                        <button for="embedded">Toggle</button> UNchecked by default.         </li>
                <li>    <input   id="external" class="external" type="checkbox" >
                        <button for="external">Toggle</button> checked by <var>page.js</var> </li>
            </ul>
            <br/>
            <input type="button" value="get"/><input type="button" value="set"/>
            <label><input type="radio" name="l" value="location" checked > location          </label>
            <label><input type="radio" name="l" value="location.href"    > location.href     </label>
            <label><input type="radio" name="l" value="window.location"  > window.location   </label>
            <label><input type="radio" name="l" value="document.location"> document.location </label>
            <textarea></textarea>

            <input type="button" value="other properties"/> &bullet;
            <input type="button" value="assign()"/>
            <input type="button" value="reload()"/>
            <input type="button" value="replace()"/> &bullet;
            <input type="button" value="location-win-doc" />
            <input type="button" value="this===window" />

            <script src="page.js" ></script>
            <h3>Visual demo</h3>
<pre>
CSS
    1. The header above should be intact(default) in color and text size.
    2. Colors in demo components and IFRAMEs should match the page name: <i id="purple-color">purple</i>, <i id="violet-color">violet</i> .
JS
    1. Checkboxes on page should not be affected by <var>embed-page</var> content.
    2. Operating the page content here should not affect the component` intestines.
Links
    1. Click on link will replace the component content with page from <var>href</var> attribute.
Form
    1. GET and POST will replace content according to FORM <var>action</var> attribute.
location & window.location & document.location
    1. page in component populates text box with value matching SRC attribute of component.
    2. clear the text box, click on GET. The full URL matching SRC attribute
       should be placed in text box
    3. change text box to <var>page-purple.html</var>, click on SET. The content of component
       should load the page
    4. repeat step 1-3 with 'href-get', 'href-set', 'location get', 'location set'
    5. add URL properties like hash, port#, query parameters, user, password.
       'other properties' should place matching key-value in text box.
    6. change URL in text box, press 'assign()' or 'replace(), matching content
       should be fetched.
    7. 'reload()' should re-fetch and re-render content. See it in network and UI.
    8. 'location-win-doc' should give true for identical 'location', 'window.location'
       , and 'document.location'
    9. 'this===window' should give true
Cookies
    1. set cookies <var>a=b</var>, set cookies <var>c=d</var>
    2. get cookie should have both key/values presented
    3. refresh page, get cookies should have both key/values presented


</pre>
        </div>
        <div style="display: inline-block">
            <legend><a href="page.  js" target="_blank">page.js</a> </legend>
            <code src="./page.js"></code>
            When used from <var>embed-page</var>, the <var>document</var> is wrapped to reflect component instance scope.<br/>
            The click will trigger just own instance checkbox.
        </div>
    </fieldset>
    <script src="../node_modules/wct-browser-legacy/browser.js"></script>
    <script>
        suite('embed-page basics IFRAME test ', () =>
        {
            let epa0, epaV, epaP, $0, $V, $P, $$ = css => document.querySelector(css);

            const EPA_0_URL = "page-violet.html"
            ,     EPA_V_URL = "page-violet.html?d=e#f"
            ,     EPA_P_URL = "page-purple.html?a=b#c"
            ,   VIOLET_COLOR = getColor( $$("#violet-color") )
            ,   PURPLE_COLOR = getColor( $$("#purple-color") );

            setup( function()
            {
                return wait4all().then( args =>
                {   [ epa0, epaV, epaP ] = args;
                    [ $0, $V,$P ] = args.map( epa => (css => epa.shadowRoot.querySelector(css) ) );
                });
            });

            test('1. initial src set', function()
            {
                assert.equal( epa0.src, EPA_0_URL ); assert.equal( epa0.getAttribute('src'), EPA_0_URL );
                assert.equal( epaV.src, EPA_V_URL ); assert.equal( epaV.getAttribute('src'), EPA_V_URL );
                assert.equal( epaP.src, EPA_P_URL ); assert.equal( epaP.getAttribute('src'), EPA_P_URL );
            });
            test('2. content loaded', function()
            {
                assert.equal( $0('h1').innerText, "Violet header" );
                assert.equal( $V('h1').innerText, "Violet header" );
                assert.equal( $P('h1').innerText, "Purple header" );
            });
            test('3. inner JS executed', function()
            {
                assert.equal( $$('#embedded').checked, false );
                assert.equal( $0('#embedded').checked, false );
                assert.equal( $V('#embedded').checked, false );
                assert.equal( $P('#embedded').checked, true  );
            });
            test('4. external page.js executed', function()
            {
                assert.equal( $$('#external').checked, true );
                assert.equal( $0('#external').checked, true );
                assert.equal( $V('#external').checked, true );
                assert.equal( $P('#external').checked, true );
            });
            test('5. internal css executed', function()
            {
                assert.notEqual( $$('h1'), VIOLET_COLOR );
                assert.notEqual( $$('h1'), PURPLE_COLOR );

                assert.equal( getColor( $0('h1') ), VIOLET_COLOR );
                assert.equal( getColor( $V('h1') ), VIOLET_COLOR );
                assert.equal( getColor( $P('h1') ), PURPLE_COLOR );
            });

            if( !window.parent.location.href.includes('/test') ) // skip if from within demo where click is manual
                return;

            test('3. onClick', function()
            {
                const E = document.getElementById("epa-1");
                assert.equal( E.readyState, "complete" );
                const s = E.shadowRoot;
                s.querySelector('button').dispatchEvent( new MouseEvent( "click" ));
                const h = s.querySelector('h3');
                const h3defaultColor = window.getComputedStyle( document.querySelector('h3'),null ).getPropertyValue('color')
                ,    h3EmbeddedColor = window.getComputedStyle(h,null).getPropertyValue('color')
                ,          spanColor = window.getComputedStyle(document.querySelector('h3 i'),null).getPropertyValue('color');
                assert.notEqual( h3defaultColor, h3EmbeddedColor );
                assert.equal( h3EmbeddedColor, spanColor );// 'chocolate'
            });

                function
            getColor( el )
            {
                return window.getComputedStyle( el, null ).getPropertyValue('color')
            }
                function
            wait4all()
            {
                return Promise.all([ wait4load( "epa-0"     , EPA_0_URL )
                                  ,  wait4load( "epa-violet", EPA_V_URL )
                                  ,  wait4load( "epa-purple", EPA_P_URL )
                                  ]);
            }
                function
            wait4load( id, url )
            {
                const E = document.getElementById( id );
                assert.notEqual( E, null );
                assert.equal( E.src, url );
                assert.equal( E.getAttribute('src'), url );
                if( "complete" === E.readyState )
                    return Promise.resolve(E);
                return new Promise( function( resolve, reject )
                {
                    E.addEventListener( 'load' , x=> resolve(E) );
                    E.addEventListener( 'error', x=> reject (E) );
                } );
            }
        });
    </script>

  </body>
</html>
